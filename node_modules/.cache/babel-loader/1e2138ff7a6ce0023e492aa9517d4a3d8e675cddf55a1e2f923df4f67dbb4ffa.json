{"ast":null,"code":"import PriorityQueue from \"priorityqueuejs\";\nconst dijkstra = (grid, startNode, endNode) => {\n  // An array to store all the visited nodes in order\n  const visitedNodesInOrder = [];\n\n  // nodesToVisit - A PriorityQueue for storing the nodes to be visited in ascending distance order\n  let nodesToVisit = new PriorityQueue((a, b) => -(a.distance - b.distance));\n\n  // Set the starting node distance to 0 and enqueue it in the priority queue\n  startNode.distance = 0;\n  nodesToVisit.enq({\n    row: startNode.row,\n    col: startNode.col,\n    distance: 0\n  });\n  while (nodesToVisit.size() > 0) {\n    const {\n      row,\n      col,\n      distance\n    } = nodesToVisit.deq();\n    let currentNode = grid[row][col];\n\n    // If the distance in the pq element is greater than the current distance skip it\n    if (distance > grid[row][col].distance) continue;\n\n    // Marking the current node as visited and pushing it to the array\n    currentNode.isVisited = true;\n    visitedNodesInOrder.push(currentNode);\n\n    // Check if the current node is end, if yes return\n    if (currentNode === endNode) return visitedNodesInOrder;\n\n    // Insert all the neighbor nodes which are not yet visited or can be reached in less distance\n    const x = [1, -1, 0, 0];\n    const y = [0, 0, 1, -1];\n    for (let i = 0; i < 4; i++) {\n      let neighborRow = row + x[i];\n      let neighborCol = col + y[i];\n\n      // Check the node is valid\n      if (neighborRow >= 0 && neighborRow < grid.length && neighborCol >= 0 && neighborCol < grid[0].length && !grid[neighborRow][neighborCol].isVisited && !grid[neighborRow][neighborCol].isWall) {\n        let neighbor = grid[neighborRow][neighborCol];\n        if (neighbor.distance > currentNode.distance + neighbor.weight + 1) {\n          neighbor.distance = currentNode.distance + neighbor.weight + 1;\n\n          // Insert the node to priority queue and update the distance\n          neighbor.previousNode = currentNode;\n          nodesToVisit.enq({\n            row: neighbor.row,\n            col: neighbor.col,\n            distance: neighbor.distance\n          });\n        }\n      }\n    }\n  }\n\n  // We cannot reach the end node, so return the visited nodes\n  return visitedNodesInOrder;\n};\n\n// Backtracks from the endNode to find the shortest path.\n// Should only be called once the dijkstra is done executing\nconst getNodesInShortestPathOrder = endNode => {\n  const nodesInShortestPathOrder = [];\n  let currentNode = endNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n};\nexport { dijkstra, getNodesInShortestPathOrder };","map":{"version":3,"names":["PriorityQueue","dijkstra","grid","startNode","endNode","visitedNodesInOrder","nodesToVisit","a","b","distance","enq","row","col","size","deq","currentNode","isVisited","push","x","y","i","neighborRow","neighborCol","length","isWall","neighbor","weight","previousNode","getNodesInShortestPathOrder","nodesInShortestPathOrder","unshift"],"sources":["C:/Users/shrut/OneDrive/Desktop/dijkstra_algo/Dijkstra-algo/Dijkstra-s-algorithm-Visualizer-main/Dijkstra-s-algorithm-Visualizer-main/src/algorithms/dijkstra.js"],"sourcesContent":["import PriorityQueue from \"priorityqueuejs\";\r\n\r\nconst dijkstra = (grid, startNode, endNode) => {\r\n  // An array to store all the visited nodes in order\r\n  const visitedNodesInOrder = [];\r\n\r\n  // nodesToVisit - A PriorityQueue for storing the nodes to be visited in ascending distance order\r\n  let nodesToVisit = new PriorityQueue((a, b) => -(a.distance - b.distance));\r\n\r\n  // Set the starting node distance to 0 and enqueue it in the priority queue\r\n  startNode.distance = 0;\r\n  nodesToVisit.enq({ row: startNode.row, col: startNode.col, distance: 0 });\r\n\r\n  while (nodesToVisit.size() > 0) {\r\n    const { row, col, distance } = nodesToVisit.deq();\r\n    let currentNode = grid[row][col];\r\n\r\n    // If the distance in the pq element is greater than the current distance skip it\r\n    if (distance > grid[row][col].distance) continue;\r\n\r\n    // Marking the current node as visited and pushing it to the array\r\n    currentNode.isVisited = true;\r\n    visitedNodesInOrder.push(currentNode);\r\n\r\n    // Check if the current node is end, if yes return\r\n    if (currentNode === endNode) return visitedNodesInOrder;\r\n\r\n    // Insert all the neighbor nodes which are not yet visited or can be reached in less distance\r\n    const x = [1, -1, 0, 0];\r\n    const y = [0, 0, 1, -1];\r\n    for (let i = 0; i < 4; i++) {\r\n      let neighborRow = row + x[i];\r\n      let neighborCol = col + y[i];\r\n\r\n      // Check the node is valid\r\n      if (\r\n        neighborRow >= 0 &&\r\n        neighborRow < grid.length &&\r\n        neighborCol >= 0 &&\r\n        neighborCol < grid[0].length &&\r\n        !grid[neighborRow][neighborCol].isVisited &&\r\n        !grid[neighborRow][neighborCol].isWall\r\n      ) {\r\n        let neighbor = grid[neighborRow][neighborCol];\r\n        if (neighbor.distance > currentNode.distance + neighbor.weight + 1) {\r\n          neighbor.distance = currentNode.distance + neighbor.weight + 1;\r\n\r\n          // Insert the node to priority queue and update the distance\r\n          neighbor.previousNode = currentNode;\r\n          nodesToVisit.enq({\r\n            row: neighbor.row,\r\n            col: neighbor.col,\r\n            distance: neighbor.distance,\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // We cannot reach the end node, so return the visited nodes\r\n  return visitedNodesInOrder;\r\n};\r\n\r\n// Backtracks from the endNode to find the shortest path.\r\n// Should only be called once the dijkstra is done executing\r\nconst getNodesInShortestPathOrder = (endNode) => {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = endNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n\r\n  return nodesInShortestPathOrder;\r\n};\r\n\r\nexport { dijkstra, getNodesInShortestPathOrder };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}